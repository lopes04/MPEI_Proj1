    % Ler dataset principal como padrão    data = readtable('dataset1_com_telefones.csv');    % Dividir a coluna única em duas: Frases e Categoria    splitData = split(data.Text, ' : ');    frases = splitData(:, 1); % Coluna com as frases    % Copiar categorias diretamente da tabela    categorias = data.Category;    % Copiar números diretamente da tabela    numeros = data.Phone;    % Dividir o dataset em treino e teste (60% treino, 40% teste)    numRows = size(data, 1); % Total de linhas    randIndices = randperm(numRows); % Gerar índices aleatórios    trainLimit = round(0.6 * numRows); % Limite de treino    trainIndices = randIndices(1:trainLimit);    testIndices = randIndices(trainLimit + 1:end);    % Separar frases, categorias e números para teste    testFrases = frases(testIndices);    testCategorias = categorias(testIndices);    testNumeros = numeros(testIndices); % Processamento das testFrasestestFrases = string(testFrases);testFrases = lower(testFrases); % Converter para minúsculastestFrasestoken = tokenizedDocument(testFrases); % Tokenizar frasescleanTestFrasestoken = removeStopWords(testFrasestoken); % Remover stopwordscleanTestFrases = joinWords(cleanTestFrasestoken); % Reunir palavrastestFrases = string(cleanTestFrases);testFrases = regexprep(testFrases, '[.,]', ''); % Remover pontos e vírgulas% -------------------------------------% Ler o dataset de SPAMspamData = readtable('fakedataset_com_telefones.csv');spamData = unique(spamData); % Remover duplicados% Dividir frases e números de telefone do fakedatasetsplitSpamData = split(spamData.Text, ' : ');spamFrases = splitSpamData(:, 1); % Coluna com as frases de SPAMspamNumeros = spamData.Phone; % Coluna com os números de telefone de SPAMspamFrases = string(spamFrases);spamFrases = lower(spamFrases); % Converter para minúsculasspamfrasestoken = tokenizedDocument(spamFrases); % Tokenizar frasescleanspamfrasestoken = removeStopWords(spamfrasestoken); % Remover stopwordscleanspamfrases = joinWords(cleanspamfrasestoken); % Reunir palavrasspamFrases = string(cleanspamfrases);spamFrases = regexprep(spamFrases, '[.,]', ''); % Remover pontos e vírgulas% Carregar números conhecidos como SPAMif isfile('lista_negra.csv')    existentSpamData = readtable('lista_negra.csv');    existentSpam = string(existentSpamData.PhoneNumber); % Converter para stringelse    disp('File "lista_negra.csv" not found. Initializing empty data.');    existentSpamData = table([], 'VariableNames', {'PhoneNumber'});    existentSpam = string([]); % Lista vaziaend% Verificar números de telefone e frases do conjunto de testevalidSpamIndices = true(length(testFrases), 1); % Inicializar todos os índices como válidosfor ctg = 1:length(testFrases)    numAtual = string(testNumeros(ctg)); % Número atual no conjunto de teste        % Verificar se o número está na lista negra    if any(strcmp(numAtual, existentSpam))        validSpamIndices(ctg) = false;        fprintf('Número %s detetado como SPAM\n', numAtual); % Mensagem de deteção    endend% Retirar as frases e números marcados como SPAMtestFrases = testFrases(validSpamIndices);testCategorias = testCategorias(validSpamIndices);testNumeros = testNumeros(validSpamIndices);%% Configuração do Bloom Filterp = 0.001;  % Probabilidade de falsos positivosm = length(spamFrases);n = round(-(m * log(p) / (log(2))^2));k = round(((n / m) * log(2)));% Inicializar Bloom FilterBF = inicializarBF(n);% Adicionar elementos ao filtrofor i = 1:m    BF = adicionarBF(BF, spamFrases{i}, k);end% Verificar falsos negativos no conjunto de treinofalsos = 0;for i = 1:m    bool = membroBF(BF, spamFrases{i}, k);    if bool == false        falsos = falsos + 1;    endend% Verificar falsos positivos no conjunto de testefalsos_positivos = 0;falsosPositivosIndices = false(length(testFrases), 1);spamPhone = {}; %cria array vazio para número de telefones que dêem falso positivofor i = 1:length(testFrases)    if membroBF(BF, testFrases{i}, k)        falsos_positivos = falsos_positivos + 1;        falsosPositivosIndices(i) = true;        % Recuperar o número de telefone associado à frase        phoneIndex = find(strcmp(testFrases{i}, testFrases));        if ~isempty(phoneIndex)            spamPhone{end + 1} = string(testNumeros(phoneIndex));  % Encontrar o número associado à frase            fprintf('Frase com falso positivo: %s\n', testFrases{i});            fprintf('Número de telefone associado: %s\n', spamPhone{end});        end    endendtestFrases = testFrases(~falsosPositivosIndices);testCategorias = testCategorias(~falsosPositivosIndices);testNumeros = testNumeros(~falsosPositivosIndices);% Exibir os resultados de falsos positivos%fprintf('Falsos positivos: %d\n', falsos_positivos);%fprintf('Probabilidade Prática de Falsos Positivos = %.3f%s\n', (falsos_positivos / length(testFrases)) * 100, "%");% Calcular e exibir a probabilidade teórica de falsos positivospfp = (1 - exp(-(k * m) / n))^k;%fprintf('Probabilidade Teórica Estimada de Falsos Positivos = %.3f%s\n', pfp * 100, "%");% Exibir os números de telefone correspondentes aos falsos positivosif isempty(spamPhone)    disp('Números de telefone associados aos falsos positivos:');    disp(spamPhone);end%transpor array para colunaspamPhone = spamPhone';% Converter em tabelanewSpamData = table(spamPhone, 'VariableNames', {'PhoneNumber'});newSpamData.PhoneNumber = string(newSpamData.PhoneNumber); % Convert to string%Adiciona novos números spam aos já existentescombinedSpamData = [existentSpamData; newSpamData];% Verificação de duplicados%combinedData = unique(combinedData);% Atualiza o CSVwritetable(combinedSpamData, 'lista_negra.csv');save BF_data.mat